<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>schema.macros documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Schema 0.2.3 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></div></li><li class="depth-2 branch"><a href="schema.coerce.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coerce</span></div></a></li><li class="depth-2 branch"><a href="schema.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch current"><a href="schema.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-2 branch"><a href="schema.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-2"><a href="schema.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="schema.macros.html#var-*use-potemkin*"><div class="inner"><span>*use-potemkin*</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-.3D.3E"><div class="inner"><span>=&gt;</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-.3D.3E*"><div class="inner"><span>=&gt;*</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-apply-prepost-conditions"><div class="inner"><span>apply-prepost-conditions</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-assert.21"><div class="inner"><span>assert!</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-assert-c.21"><div class="inner"><span>assert-c!</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-compiling-cljs-now.3F"><div class="inner"><span>compiling-cljs-now?</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-compiling-cljs.3F"><div class="inner"><span>compiling-cljs?</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-def"><div class="inner"><span>def</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-defmethod"><div class="inner"><span>defmethod</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-defn"><div class="inner"><span>defn</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-defrecord"><div class="inner"><span>defrecord</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-defschema"><div class="inner"><span>defschema</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-error.21"><div class="inner"><span>error!</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-extract-arrow-schematized-element"><div class="inner"><span>extract-arrow-schematized-element</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-extract-schema-form"><div class="inner"><span>extract-schema-form</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-fix-protocol-tag"><div class="inner"><span>fix-protocol-tag</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-fn"><div class="inner"><span>fn</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-input-schema-form"><div class="inner"><span>input-schema-form</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-letfn"><div class="inner"><span>letfn</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-looks-like-a-protocol-var.3F"><div class="inner"><span>looks-like-a-protocol-var?</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-maybe-split-first"><div class="inner"><span>maybe-split-first</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-normalized-metadata"><div class="inner"><span>normalized-metadata</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-primitive-sym.3F"><div class="inner"><span>primitive-sym?</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-process-arrow-schematized-args"><div class="inner"><span>process-arrow-schematized-args</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-process-fn-"><div class="inner"><span>process-fn-</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-process-fn-arity"><div class="inner"><span>process-fn-arity</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-protocol"><div class="inner"><span>protocol</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-rest-arg-schema-form"><div class="inner"><span>rest-arg-schema-form</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-safe-get"><div class="inner"><span>safe-get</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-simple-arglist-schema-form"><div class="inner"><span>simple-arglist-schema-form</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-single-arg-schema-form"><div class="inner"><span>single-arg-schema-form</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-split-rest-arg"><div class="inner"><span>split-rest-arg</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-try-catchall"><div class="inner"><span>try-catchall</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-valid-tag.3F"><div class="inner"><span>valid-tag?</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-validation-error"><div class="inner"><span>validation-error</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-with-fn-validation"><div class="inner"><span>with-fn-validation</span></div></a></li><li class="depth-1"><a href="schema.macros.html#var-without-fn-validation"><div class="inner"><span>without-fn-validation</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">schema.macros</h2><div class="doc"><pre class="plaintext">Macros used in and provided by schema, separated out for Clojurescript&apos;s sake.
</pre></div><div class="public anchor" id="var-*use-potemkin*"><h3>*use-potemkin*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Should we generate records based on potemkin/defrecord+, rather than Clojure&apos;s
defrecord? Turned on by default for Clojure at the bottom of schema.core.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L336">view source</a></div></div><div class="public anchor" id="var-.3D.3E"><h3>=&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(=&gt; output-schema &amp; arg-schemas)</code></div><div class="doc"><pre class="plaintext">Convenience function for defining function schemas with a single arity; like =&gt;*, but
there is no vector around the argument schemas for this arity.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L327">view source</a></div></div><div class="public anchor" id="var-.3D.3E*"><h3>=&gt;*</h3><h4 class="type">macro</h4><div class="usage"><code>(=&gt;* output-schema &amp; arity-schema-specs)</code></div><div class="doc"><pre class="plaintext">Produce a function schema from an output schema and a list of arity input schema specs,
each of which is a vector of argument schemas, ending with an optional &apos;&amp; more-schema&apos;
specification where more-schema must be a sequence schema.

Currently function schemas are purely descriptive; there is no validation except for
functions defined directly by s/fn or s/defn</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L317">view source</a></div></div><div class="public anchor" id="var-apply-prepost-conditions"><h3>apply-prepost-conditions</h3><div class="usage"><code>(apply-prepost-conditions body)</code></div><div class="doc"><pre class="plaintext">Replicate pre/postcondition logic from clojure.core/fn.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L196">view source</a></div></div><div class="public anchor" id="var-assert.21"><h3>assert!</h3><h4 class="type">macro</h4><div class="usage"><code>(assert! form &amp; format-args)</code></div><div class="doc"><pre class="plaintext">Like assert, but throws a RuntimeException and takes args to format.  Only
for use in client-code.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L59">view source</a></div></div><div class="public anchor" id="var-assert-c.21"><h3>assert-c!</h3><h4 class="type">macro</h4><div class="usage"><code>(assert-c! form &amp; format-args)</code></div><div class="doc"><pre class="plaintext">Like assert! but throws a RuntimeException and takes args to format.  Only
for use during compilation.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L66">view source</a></div></div><div class="public anchor" id="var-compiling-cljs-now.3F"><h3>compiling-cljs-now?</h3><h4 class="type">macro</h4><div class="usage"><code>(compiling-cljs-now?)</code></div><div class="doc"><pre class="plaintext">Helper macro to test compiling-cljs?
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L22">view source</a></div></div><div class="public anchor" id="var-compiling-cljs.3F"><h3>compiling-cljs?</h3><div class="usage"><code>(compiling-cljs?)</code></div><div class="doc"><pre class="plaintext">Return true if we are currently generating cljs code.  Useful because cljx does not
provide a hook for conditional macro expansion.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L13">view source</a></div></div><div class="public anchor" id="var-def"><h3>def</h3><h4 class="type">macro</h4><div class="usage"><code>(def &amp; def-args)</code></div><div class="doc"><pre class="plaintext">Like def, but takes a schema on the var name (with the same format
as the output schema of s/defn), requires an initial value, and
asserts that the initial value matches the schema on the var name
(regardless of the status of with-fn-validation).  Due to
limitations of add-watch!, cannot enforce validation of subsequent
rebindings of var.  Throws at compile-time for clj, and client-side
load-time for cljs.

Example:

(s/def foo :- long &quot;a long&quot; 2)</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L557">view source</a></div></div><div class="public anchor" id="var-defmethod"><h3>defmethod</h3><h4 class="type">macro</h4><div class="usage"><code>(defmethod multifn dispatch-val &amp; fn-tail)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/defmethod, except that schema-style typehints can be given on
the argument symbols and after the dispatch-val (for the return value).

See (doc schema.macros/defn) for details.

Examples:

  (s/defmethod mymultifun :a-dispatch-value :- s/Num [x :- s/Int y :- s/Num] (* x y))

  ;; You can also use meta tags like ^:always-validate by placing them
  ;; before the multifunction name:

  (s/defmethod ^:always-validate mymultifun :a-dispatch-value [x y] (* x y))
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L581">view source</a></div></div><div class="public anchor" id="var-defn"><h3>defn</h3><h4 class="type">macro</h4><div class="usage"><code>(defn &amp; defn-args)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/defn, except that schema-style typehints can be given on
the argument symbols and on the function name (for the return value).

You can call s/fn-schema on the defined function to get its schema back, or
use with-fn-validation to enable runtime checking of function inputs and
outputs.

(sm/defn foo :- s/Num
 [x :- s/Int
  y :- s/Num]
 (* x y))

(s/fn-schema foo)
==&gt; (=&gt; java.lang.Number Int java.lang.Number)

(sm/with-fn-validation (foo 1 2))
==&gt; 2

(sm/with-fn-validation (foo 1.5 2))
==&gt; Input to foo does not match schema: [(named (not (integer? 1.5)) x) nil]

See (doc schema.core) for details of the :- syntax for arguments and return
schemas.

The overhead for checking if run-time validation should be used is very
small -- about 5% of a very small fn call.  On top of that, actual
validation costs what it costs.

You can also turn on validation unconditionally for this fn only by
putting ^:always-validate metadata on the fn name.

Gotchas and limitations:
 - The output schema always goes on the fn name, not the arg vector. This
   means that all arities must share the same output schema. Schema will
   automatically propagate primitive hints to the arg vector and class hints
   to the fn name, so that you get the behavior you expect from Clojure.
 - Schema metadata is only processed on top-level arguments.  I.e., you can
   use destructuring, but you must put schema metadata on the top-level
   arguments, not the destructured variables.

   Bad:  (sm/defn foo [{:keys [x :- s/Int]}])
   Good: (sm/defn foo [{:keys [x]} :- {:x s/Int}])
 - Only a specific subset of rest-arg destructuring is supported:
   - &amp; rest works as expected
   - &amp; [a b] works, with schemas for individual elements parsed out of the binding,
     or an overall schema on the vector
   - &amp; {} is not supported.
 - Unlike clojure.core/defn, a final attr-map on multi-arity functions
   is not supported.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L453">view source</a></div></div><div class="public anchor" id="var-defrecord"><h3>defrecord</h3><h4 class="type">macro</h4><div class="usage"><code>(defrecord name field-schema extra-key-schema? extra-validator-fn? &amp; opts+specs)</code></div><div class="doc"><pre class="plaintext">Define a record with a schema.  If *use-potemkin* is true, the resulting record
is a potemkin/defrecord+, otherwise it is a defrecord.

In addition to the ordinary behavior of defrecord, this macro produces a schema
for the Record, which will automatically be used when validating instances of
the Record class:

(sm/defrecord FooBar
 [foo :- Int
  bar :- String])

(schema.utils/class-schema FooBar)
==&gt; (record user.FooBar {:foo Int, :bar java.lang.String})

(s/check FooBar (FooBar. 1.2 :not-a-string))
==&gt; {:foo (not (integer? 1.2)), :bar (not (instance? java.lang.String :not-a-string))}

See (doc schema.core) for details of the :- syntax for record elements.

Moreover, optional arguments extra-key-schema? and extra-validator-fn? can be
passed to augment the record schema.
 - extra-key-schema is a map schema that defines validation for additional
   key-value pairs not in the record base (the default is to not allow extra
    mappings).
 - extra-validator-fn? is an additional predicate that will be used as part
   of validating the record value.

The remaining opts+specs (i.e., protocol and interface implementations) are
passed through directly to defrecord.

Finally, this macro replaces Clojure&apos;s map-&gt;name constructor with one that is
more than an order of magnitude faster (as of Clojure 1.5), and provides a
new strict-map-&gt;name constructor that throws or drops extra keys not in the
record base.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L341">view source</a></div></div><div class="public anchor" id="var-defschema"><h3>defschema</h3><h4 class="type">macro</h4><div class="usage"><code>(defschema name form)</code><code>(defschema name docstring form)</code></div><div class="doc"><pre class="plaintext">Convenience macro to make it clear to reader that body is meant to be used as a schema.
The name of the schema is recorded in the metadata.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L300">view source</a></div></div><div class="public anchor" id="var-error.21"><h3>error!</h3><h4 class="type">macro</h4><div class="usage"><code>(error! s)</code><code>(error! s m)</code></div><div class="doc"><pre class="plaintext">Generate a cross-platform exception in client (non-compilation) code.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L39">view source</a></div></div><div class="public anchor" id="var-extract-arrow-schematized-element"><h3>extract-arrow-schematized-element</h3><div class="usage"><code>(extract-arrow-schematized-element env s)</code></div><div class="doc"><pre class="plaintext">Take a nonempty seq, which may start like [a ...] or [a :- schema ...], and return
a list of [first-element-with-schema-attached rest-elements]</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L132">view source</a></div></div><div class="public anchor" id="var-extract-schema-form"><h3>extract-schema-form</h3><div class="usage"><code>(extract-schema-form symbol)</code></div><div class="doc"><pre class="plaintext">Pull out the schema stored on a thing.  Public only because of its use in a public macro.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L125">view source</a></div></div><div class="public anchor" id="var-fix-protocol-tag"><h3>fix-protocol-tag</h3><div class="usage"><code>(fix-protocol-tag env tag)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L93">view source</a></div></div><div class="public anchor" id="var-fn"><h3>fn</h3><h4 class="type">macro</h4><div class="usage"><code>(fn &amp; fn-args)</code></div><div class="doc"><pre class="plaintext">sm/fn : sm/defn :: clojure.core/fn : clojure.core/defn

See (doc schema.macros/defn) for details.

Additional gotchas and limitations:
 - Like s/defn, the output schema must go on the fn name.  If you want an
   output schema, your function must have a name.
 - Unlike s/defn, the function schema is stored in metadata on the fn.
   Clojure&apos;s implementation for metadata on fns currently produces a
   wrapper fn, which will decrease performance and negate the benefits
   of primitive type hints compared to clojure.core/fn.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L433">view source</a></div></div><div class="public anchor" id="var-input-schema-form"><h3>input-schema-form</h3><div class="usage"><code>(input-schema-form regular-args rest-arg)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L190">view source</a></div></div><div class="public anchor" id="var-letfn"><h3>letfn</h3><h4 class="type">macro</h4><div class="usage"><code>(letfn fnspecs# &amp; body#)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L529">view source</a></div></div><div class="public anchor" id="var-looks-like-a-protocol-var.3F"><h3>looks-like-a-protocol-var?</h3><div class="usage"><code>(looks-like-a-protocol-var? v)</code></div><div class="doc"><pre class="plaintext">There is no &apos;protocol?&apos;in Clojure, so here&apos;s a half-assed attempt.
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L85">view source</a></div></div><div class="public anchor" id="var-maybe-split-first"><h3>maybe-split-first</h3><div class="usage"><code>(maybe-split-first pred s)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L80">view source</a></div></div><div class="public anchor" id="var-normalized-metadata"><h3>normalized-metadata</h3><div class="usage"><code>(normalized-metadata env imeta explicit-schema)</code></div><div class="doc"><pre class="plaintext">Take an object with optional metadata, which may include a :tag and/or explicit
:schema/:s/:s?/:tag data, plus an optional explicit schema, and normalize the
object to have a valid Clojure :tag plus a :schema field. :s? is deprecated.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L106">view source</a></div></div><div class="public anchor" id="var-primitive-sym.3F"><h3>primitive-sym?</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L100">view source</a></div></div><div class="public anchor" id="var-process-arrow-schematized-args"><h3>process-arrow-schematized-args</h3><div class="usage"><code>(process-arrow-schematized-args env args)</code></div><div class="doc"><pre class="plaintext">Take an arg vector, in which each argument is followed by an optional :- schema,
and transform into an ordinary arg vector where the schemas are metadata on the args.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L142">view source</a></div></div><div class="public anchor" id="var-process-fn-"><h3>process-fn-</h3><div class="usage"><code>(process-fn- env name fn-body)</code></div><div class="doc"><pre class="plaintext">Process the fn args into a final tag proposal, schema form, schema bindings, and fn form
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L261">view source</a></div></div><div class="public anchor" id="var-process-fn-arity"><h3>process-fn-arity</h3><div class="usage"><code>(process-fn-arity env fn-name output-schema-sym bind-meta [bind &amp; body])</code></div><div class="doc"><pre class="plaintext">Process a single (bind &amp; body) form, producing an output tag, schema-form,
and arity-form which has asserts for validation purposes added that are
executed when turned on, and have very low overhead otherwise.
tag? is a prospective tag for the fn symbol based on the output schema.
schema-bindings are bindings to lift eval outwards, so we don&apos;t build the schema
every time we do the validation.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L207">view source</a></div></div><div class="public anchor" id="var-protocol"><h3>protocol</h3><h4 class="type">macro</h4><div class="usage"><code>(protocol p)</code></div><div class="doc"><pre class="plaintext">A value that must satsify? protocol p
</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L310">view source</a></div></div><div class="public anchor" id="var-rest-arg-schema-form"><h3>rest-arg-schema-form</h3><div class="usage"><code>(rest-arg-schema-form arg)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L181">view source</a></div></div><div class="public anchor" id="var-safe-get"><h3>safe-get</h3><h4 class="type">macro</h4><div class="usage"><code>(safe-get m k)</code></div><div class="doc"><pre class="plaintext">Like get but throw an exception if not found.  A macro just to work around cljx function
placement restrictions.  Only valid in client (non-compilation) code.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L50">view source</a></div></div><div class="public anchor" id="var-simple-arglist-schema-form"><h3>simple-arglist-schema-form</h3><div class="usage"><code>(simple-arglist-schema-form rest? regular-args)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L178">view source</a></div></div><div class="public anchor" id="var-single-arg-schema-form"><h3>single-arg-schema-form</h3><div class="usage"><code>(single-arg-schema-form rest? [index arg])</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L171">view source</a></div></div><div class="public anchor" id="var-split-rest-arg"><h3>split-rest-arg</h3><div class="usage"><code>(split-rest-arg env bind)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L156">view source</a></div></div><div class="public anchor" id="var-try-catchall"><h3>try-catchall</h3><h4 class="type">macro</h4><div class="usage"><code>(try-catchall &amp; body)</code></div><div class="doc"><pre class="plaintext">A variant of try-catch that catches all exceptions in client (non-compilation) code.
Does not (yet) support finally, and does not need or want an exception class.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L27">view source</a></div></div><div class="public anchor" id="var-valid-tag.3F"><h3>valid-tag?</h3><div class="usage"><code>(valid-tag? env tag)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L103">view source</a></div></div><div class="public anchor" id="var-validation-error"><h3>validation-error</h3><h4 class="type">macro</h4><div class="usage"><code>(validation-error schema value expectation &amp; [fail-explanation])</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L73">view source</a></div></div><div class="public anchor" id="var-with-fn-validation"><h3>with-fn-validation</h3><h4 class="type">macro</h4><div class="usage"><code>(with-fn-validation &amp; body)</code></div><div class="doc"><pre class="plaintext">Execute body with input and ouptut schema validation turned on for
all s/defn and s/fn instances globally (across all threads). After
all forms have been executed, resets function validation to its
previously set value. Not concurrency-safe.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L535">view source</a></div></div><div class="public anchor" id="var-without-fn-validation"><h3>without-fn-validation</h3><h4 class="type">macro</h4><div class="usage"><code>(without-fn-validation &amp; body)</code></div><div class="doc"><pre class="plaintext">Execute body with input and ouptut schema validation turned off for
all s/defn and s/fn instances globally (across all threads). After
all forms have been executed, resets function validation to its
previously set value. Not concurrency-safe.</pre></div><div class="src-link"><a href="http://github.com/prismatic/schema/blob/master/src/clj/schema/macros.clj#L546">view source</a></div></div></div></body></html>